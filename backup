import discord
from discord.ext import commands
import os
from dotenv import load_dotenv
import yt_dlp
import asyncio
import requests
import json

# Tải biến môi trường
load_dotenv()
BOT_TOKEN = os.getenv('BOT_TOKEN')
GROQ_API_KEY = os.getenv('GROQ_API_KEY')
CHANNEL_ID = os.getenv('CHANNEL_ID')
WELCOME_CHANNEL_ID = os.getenv('WELCOME_CHANNEL_ID')

# Kiểm tra biến môi trường
if not all([BOT_TOKEN, GROQ_API_KEY, CHANNEL_ID, WELCOME_CHANNEL_ID]):
    raise ValueError("Một hoặc nhiều biến môi trường chưa được thiết lập trong file .env")

# Chuyển đổi CHANNEL_ID và WELCOME_CHANNEL_ID sang int
try:
    CHANNEL_ID = int(CHANNEL_ID)
    WELCOME_CHANNEL_ID = int(WELCOME_CHANNEL_ID)
except (TypeError, ValueError):
    raise ValueError("CHANNEL_ID và WELCOME_CHANNEL_ID phải là số hợp lệ")

# Khởi tạo intents
intents = discord.Intents.default()
intents.members = True
intents.message_content = True

# Khởi tạo bot
bot = commands.Bot(command_prefix='!', intents=intents)

# Dictionary để lưu trữ queue nhạc cho mỗi guild
queues = {}

# Sự kiện khi bot sẵn sàng
@bot.event
async def on_ready():
    print(f'{bot.user} đã kết nối với Discord!')

# Hàm gọi API Groq
def get_groq_response(message):
    url = "https://api.groq.com/openai/v1/chat/completions"
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {GROQ_API_KEY}"
    }
    data = {
        "model": "llama3-8b-8192",
        "messages": [
            {"role": "system", "content": "You are a helpful assistant. Keep responses concise, under 1500 characters."},
            {"role": "user", "content": message}
        ],
        "max_tokens": 1500,
        "stream": False
    }
    try:
        response = requests.post(url, headers=headers, data=json.dumps(data))
        response.raise_for_status()
        return response.json()["choices"][0]["message"]["content"]
    except requests.exceptions.RequestException as e:
        return f"Lỗi khi gọi API Groq: {str(e)}"

# Xử lý tin nhắn cho chatbot
@bot.event
async def on_message(message):
    if message.author == bot.user:
        return
    if message.channel.id == CHANNEL_ID:
        response = get_groq_response(message.content)
        if len(response) > 2000:
            response = response[:1997] + "..."  # Cắt ngắn nếu quá dài
        await message.channel.send(response)
    await bot.process_commands(message)

# Thông báo thành viên mới
@bot.event
async def on_member_join(member):
    channel = bot.get_channel(WELCOME_CHANNEL_ID)
    if channel:
        await channel.send(f'Chào mừng {member.mention} đến với server!')

# Lệnh tham gia kênh voice
@bot.command(name='join', help='Tham gia kênh voice của người dùng')
async def join(ctx):
    if ctx.author.voice is None:
        await ctx.send('Bạn chưa ở trong kênh voice.')
        return
    channel = ctx.author.voice.channel
    if ctx.voice_client is not None:
        await ctx.voice_client.move_to(channel)
    else:
        await channel.connect()
    await ctx.send('Đã tham gia kênh voice.')

# Lệnh phát nhạc
@bot.command(name='play', help='Thêm bài hát vào queue và phát nếu chưa có bài nào đang phát')
async def play(ctx, url: str):
    global queues
    guild_id = str(ctx.guild.id)
    if guild_id not in queues:
        queues[guild_id] = []

    ydl_opts = {
        'format': 'bestaudio[acodec=mp3]/bestaudio',  # Prioritize MP3 for faster processing
        'noplaylist': True,
        'cachedir': os.path.join(os.getcwd(), 'yt_dlp_cache'),  # Enable caching
        'socket_timeout': 10,  # Reduce timeout for faster failure
    }
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            audio_url = info['url']
            title = info.get('title', 'Unknown')
            queues[guild_id].append((url, audio_url, title))  # Store pre-fetched URL
            await ctx.send(f'Đã thêm vào queue: {title}')
    except Exception as e:
        await ctx.send(f'Lỗi khi thêm {url} vào queue: {e}')
        return

    voice_client = ctx.voice_client
    if voice_client is None:
        if ctx.author.voice is None:
            await ctx.send("Bạn chưa ở trong kênh voice.")
            return
        else:
            voice_client = await ctx.author.voice.channel.connect()

    if not voice_client.is_playing():
        await play_next(ctx, voice_client)

# Hàm phát bài hát tiếp theo
async def play_next(ctx, voice_client):
    guild_id = str(ctx.guild.id)
    queue = queues.get(guild_id, [])
    if len(queue) == 0:
        return
    url, audio_url, title = queue.pop(0)
    try:
        ffmpeg_options = {
            'options': '-reconnect 1 -reconnect_streamed 1 -bufsize 64k'  # Low-latency options
        }
        def after_playing(error):
            if error:
                print(f'Lỗi: {error}')
            bot.loop.call_soon_threadsafe(asyncio.create_task, play_next(ctx, voice_client))
        voice_client.play(discord.FFmpegPCMAudio(audio_url, **ffmpeg_options), after=after_playing)
        await ctx.send(f'Đang phát: {title}')
    except Exception as e:
        await ctx.send(f'Lỗi khi phát {title}: {e}')
        await play_next(ctx, voice_client)

# Lệnh hiển thị queue
@bot.command(name='queue', help='Hiển thị danh sách queue nhạc hiện tại')
async def show_queue(ctx):
    guild_id = str(ctx.guild.id)
    queue = queues.get(guild_id, [])
    if len(queue) == 0:
        await ctx.send('Queue hiện tại đang trống.')
    else:
        queue_list = '\n'.join([f'{i+1}. {title}' for i, (url, audio_url, title) in enumerate(queue)])
        await ctx.send(f'Danh sách queue:\n{queue_list}')

# Lệnh dừng nhạc
@bot.command(name='stop', help='Dừng phát nhạc')
async def stop(ctx):
    voice_client = ctx.voice_client
    if voice_client is None:
        await ctx.send('Chưa kết nối với kênh voice')
        return
    voice_client.stop()
    await ctx.send('Đã dừng nhạc')

# Lệnh rời kênh voice
@bot.command(name='leave', help='Rời khỏi kênh voice')
async def leave(ctx):
    voice_client = ctx.voice_client
    if voice_client is None:
        await ctx.send('Chưa kết nối với kênh voice')
        return
    await voice_client.disconnect()
    await ctx.send('Đã rời khỏi kênh voice')

# Chạy bot
bot.run(BOT_TOKEN)