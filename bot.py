import discord
from discord import app_commands
from discord.ext import commands
import requests
import json
import logging
import asyncio
import yt_dlp
from config import BOT_TOKEN, GROQ_API_KEY, CHANNEL_ID, WELCOME_CHANNEL_ID
from database import init_db, add_message, get_history, get_queue, clear_queue
from music_player import play_song, play_playlist, play_next, get_progress_bar

# Set up logging to local file
logging.basicConfig(filename=r'./data/bot.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Discord bot setup
intents = discord.Intents.default()
intents.members = True
intents.message_content = True
bot = commands.Bot(command_prefix='!', intents=intents)

# Dictionary to store music queues in memory (synced with database)
queues = {}
loop_status = {}  # ƒê·ªÉ theo d√µi tr·∫°ng th√°i l·∫∑p l·∫°i

def get_groq_response(channel_id, message):
    history = get_history(channel_id)
    history.append({"role": "user", "content": message})
    full_history = [{"role": "system", "content": "You are a helpful assistant."}] + history
    url = "https://api.groq.com/openai/v1/chat/completions"
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {GROQ_API_KEY}"
    }
    data = {
        "model": "llama3-8b-8192",
        "messages": full_history,
        "max_tokens": 8192,
        "stream": False
    }
    try:
        response = requests.post(url, headers=headers, data=json.dumps(data))
        response.raise_for_status()
        api_response = response.json()["choices"][0]["message"]["content"]
        add_message(channel_id, None, "assistant", api_response)
        return api_response
    except requests.exceptions.RequestException as e:
        logging.error(f"Groq API error: {str(e)}")
        return f"Error calling Groq API: {str(e)}"

async def safe_voice_connect(ctx, timeout=10, retries=3):
    """Safely connect to voice channel with retries and timeout handling"""
    if ctx.author.voice is None:
        await ctx.send('‚ùå B·∫°n ch∆∞a ·ªü trong k√™nh voice.')
        return None
    
    channel = ctx.author.voice.channel
    
    if ctx.voice_client is not None:
        if ctx.voice_client.channel == channel:
            return ctx.voice_client
        else:
            try:
                await ctx.voice_client.move_to(channel)
                return ctx.voice_client
            except Exception as e:
                logging.error(f"Error moving to voice channel: {e}")
                await ctx.voice_client.disconnect()
    
    for attempt in range(retries):
        try:
            await ctx.send(f'üîÑ ƒêang k·∫øt n·ªëi ƒë·∫øn k√™nh voice... (L·∫ßn th·ª≠ {attempt + 1}/{retries})')
            voice_client = await channel.connect(timeout=timeout, reconnect=True, self_deaf=True)
            await ctx.send(f'‚úÖ ƒê√£ k·∫øt n·ªëi ƒë·∫øn k√™nh voice: **{channel.name}**')
            logging.info(f"Successfully connected to voice channel {channel.name} on attempt {attempt + 1}")
            return voice_client
        except asyncio.TimeoutError:
            logging.warning(f"Voice connection timeout on attempt {attempt + 1}")
            if attempt < retries - 1:
                await ctx.send(f'‚è∞ K·∫øt n·ªëi b·ªã timeout, ƒëang th·ª≠ l·∫°i...')
                await asyncio.sleep(2)
            else:
                await ctx.send('‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn k√™nh voice sau nhi·ªÅu l·∫ßn th·ª≠. Vui l√≤ng th·ª≠ l·∫°i sau.')
        except Exception as e:
            logging.error(f"Voice connection error on attempt {attempt + 1}: {e}")
            if attempt < retries - 1:
                await ctx.send(f'‚ùå L·ªói k·∫øt n·ªëi, ƒëang th·ª≠ l·∫°i...')
                await asyncio.sleep(2)
            else:
                await ctx.send(f'‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn k√™nh voice: {str(e)}')
    
    return None

@bot.event
async def on_ready():
    print(f'{bot.user} ƒë√£ k·∫øt n·ªëi v·ªõi Discord!')
    init_db()
    for guild in bot.guilds:
        guild_id = str(guild.id)
        queues[guild_id] = get_queue(guild_id)
    await bot.tree.sync()  # ƒê·ªìng b·ªô slash commands
    logging.info("Bot started, databases initialized, queues loaded, and slash commands synced")

@bot.event
async def on_message(message):
    if message.author == bot.user:
        return
    if message.channel.id == CHANNEL_ID:
        add_message(message.channel.id, message.id, "user", message.content)
        response = get_groq_response(message.channel.id, message.content)
        if len(response) <= 2000:
            await message.channel.send(response)
        else:
            chunks = [response[i:i+2000] for i in range(0, len(response), 2000)]
            for chunk in chunks:
                await message.channel.send(chunk)
    await bot.process_commands(message)

@bot.event
async def on_member_join(member):
    channel = bot.get_channel(WELCOME_CHANNEL_ID)
    if channel:
        await channel.send(f'Ch√†o m·ª´ng {member.mention} ƒë·∫øn v·ªõi server!')
        logging.info(f"Welcome message sent for {member.name}")

@bot.event
async def on_voice_state_update(member, before, after):
    if member == bot.user:
        return
    
    if before.channel and bot.user in before.channel.members:
        human_members = [m for m in before.channel.members if not m.bot]
        if len(human_members) == 0:
            voice_client = discord.utils.get(bot.voice_clients, guild=before.channel.guild)
            if voice_client:
                await asyncio.sleep(30)
                human_members = [m for m in before.channel.members if not m.bot]
                if len(human_members) == 0:
                    await voice_client.disconnect()
                    logging.info(f"Disconnected from empty voice channel in guild {before.channel.guild.id}")

# Slash Commands
@bot.tree.command(name="play", description="Ph√°t nh·∫°c t·ª´ URL YouTube/Spotify ho·∫∑c t√¨m ki·∫øm theo t·ª´ kh√≥a")
@app_commands.describe(query="T√™n b√†i h√°t, URL YouTube ho·∫∑c Spotify")
async def play(interaction: discord.Interaction, query: str):
    await interaction.response.defer()
    ctx = await bot.get_context(interaction)
    voice_client = await safe_voice_connect(ctx)
    if voice_client is None:
        await interaction.followup.send("‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi voice channel!")
        return
    
    try:
        if "list=" in query or "playlist" in query.lower():
            if await play_playlist(ctx, query, queues):
                if not voice_client.is_playing():
                    await play_next(ctx, voice_client, queues, bot)
                await interaction.followup.send("üé∂ ƒê√£ th√™m playlist v√†o queue!")
        else:
            if await play_song(ctx, query, queues):
                if not voice_client.is_playing():
                    await play_next(ctx, voice_client, queues, bot)
                await interaction.followup.send("üéµ ƒê√£ th√™m b√†i h√°t v√†o queue!")
    except Exception as e:
        await interaction.followup.send(f'‚ùå L·ªói khi ph√°t nh·∫°c: {str(e)}')
        logging.error(f"Error in play command: {e}")

@bot.tree.command(name="skip", description="B·ªè qua b√†i h√°t hi·ªán t·∫°i")
async def skip(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    voice_client = ctx.voice_client
    if voice_client is None or not voice_client.is_playing():
        await interaction.response.send_message('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t.')
        return
    voice_client.stop()
    await interaction.response.send_message('‚è≠Ô∏è ƒê√£ b·ªè qua b√†i h√°t hi·ªán t·∫°i.')
    logging.info(f"Skipped current song in guild {ctx.guild.id}")

@bot.tree.command(name="pause", description="T·∫°m d·ª´ng b√†i h√°t ƒëang ph√°t")
async def pause(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    voice_client = ctx.voice_client
    if voice_client is None or not voice_client.is_playing():
        await interaction.response.send_message('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t ƒë·ªÉ t·∫°m d·ª´ng.')
        return
    voice_client.pause()
    await interaction.response.send_message('‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng b√†i h√°t.')
    logging.info(f"Paused music in guild {ctx.guild.id}")

@bot.tree.command(name="resume", description="Ti·∫øp t·ª•c ph√°t b√†i h√°t ƒë√£ t·∫°m d·ª´ng")
async def resume(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    voice_client = ctx.voice_client
    if voice_client is None or not voice_client.is_paused():
        await interaction.response.send_message('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang t·∫°m d·ª´ng ƒë·ªÉ ti·∫øp t·ª•c.')
        return
    voice_client.resume()
    await interaction.response.send_message('‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c ph√°t b√†i h√°t.')
    logging.info(f"Resumed music in guild {ctx.guild.id}")

@bot.tree.command(name="queue", description="Hi·ªÉn th·ªã danh s√°ch queue nh·∫°c hi·ªán t·∫°i")
async def show_queue(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    guild_id = str(ctx.guild.id)
    queue = queues.get(guild_id, [])
    if len(queue) == 0:
        await interaction.response.send_message('üìã Queue hi·ªán t·∫°i ƒëang tr·ªëng.')
    else:
        queue_list = []
        for i, (url, audio_url, title, duration) in enumerate(queue):
            duration_str = f"{duration // 60}:{duration % 60:02d}" if duration > 0 else "Unknown"
            status = "üéµ **ƒêang ph√°t**" if i == 0 else f"{i+1}."
            queue_list.append(f'{status} **{title}** ({duration_str})')
        
        result = f'üéµ **Danh s√°ch queue ({len(queue)} b√†i):**\n\n' + '\n'.join(queue_list)
        await interaction.response.send_message(result[:2000])
        logging.info(f"Displayed queue for guild {guild_id}")

@bot.tree.command(name="now", description="Hi·ªÉn th·ªã b√†i h√°t ƒëang ph√°t")
async def now_playing(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    voice_client = ctx.voice_client
    if voice_client is None or not voice_client.is_playing():
        await interaction.response.send_message('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t.')
        return
    
    guild_id = str(ctx.guild.id)
    queue = queues.get(guild_id, [])
    if queue:
        url, _, title, duration = queue[0]
        duration_str = f"{duration // 60}:{duration % 60:02d}" if duration > 0 else "Unknown"
        await interaction.response.send_message(f'üéµ **ƒêang ph√°t:** {title} ({duration_str})')
    else:
        await interaction.response.send_message('üéµ ƒêang ph√°t nh·∫°c.')

@bot.tree.command(name="stop", description="D·ª´ng ph√°t nh·∫°c v√† x√≥a queue")
async def stop(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    voice_client = ctx.voice_client
    if voice_client is None:
        await interaction.response.send_message('‚ùå Ch∆∞a k·∫øt n·ªëi v·ªõi k√™nh voice')
        return
    
    voice_client.stop()
    guild_id = str(ctx.guild.id)
    clear_queue(guild_id)
    queues[guild_id] = []
    loop_status[guild_id] = {"mode": "off", "current_song": None, "start_time": None}
    await interaction.response.send_message('‚èπÔ∏è ƒê√£ d·ª´ng nh·∫°c v√† x√≥a queue.')
    logging.info(f"Stopped music and cleared queue for guild {ctx.guild.id}")

@bot.tree.command(name="leave", description="R·ªùi kh·ªèi k√™nh voice")
async def leave(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    voice_client = ctx.voice_client
    if voice_client is None:
        await interaction.response.send_message('‚ùå Ch∆∞a k·∫øt n·ªëi v·ªõi k√™nh voice')
        return
    
    clear_queue(str(ctx.guild.id))
    queues[str(ctx.guild.id)] = []
    loop_status[str(ctx.guild.id)] = {"mode": "off", "current_song": None, "start_time": None}
    await voice_client.disconnect()
    await interaction.response.send_message('üëã ƒê√£ r·ªùi kh·ªèi k√™nh voice.')
    logging.info(f"Left voice channel for guild {ctx.guild.id}")

@bot.tree.command(name="loop", description="B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô l·∫∑p l·∫°i b√†i h√°t ho·∫∑c queue")
@app_commands.describe(mode="Ch·ªçn ch·∫ø ƒë·ªô: off, song, queue")
@app_commands.choices(mode=[
    app_commands.Choice(name="T·∫Øt", value="off"),
    app_commands.Choice(name="L·∫∑p b√†i h√°t", value="song"),
    app_commands.Choice(name="L·∫∑p queue", value="queue")
])
async def loop(interaction: discord.Interaction, mode: str):
    ctx = await bot.get_context(interaction)
    guild_id = str(ctx.guild.id)
    
    if mode not in ["off", "song", "queue"]:
        await interaction.response.send_message("‚ùå Ch·∫ø ƒë·ªô kh√¥ng h·ª£p l·ªá! Ch·ªçn: off, song, queue")
        return
    
    loop_status[guild_id] = loop_status.get(guild_id, {})
    loop_status[guild_id]["mode"] = mode
    
    if mode == "off":
        await interaction.response.send_message("üîÅ ƒê√£ t·∫Øt ch·∫ø ƒë·ªô l·∫∑p l·∫°i.")
    elif mode == "song":
        await interaction.response.send_message("üîÇ ƒê√£ b·∫≠t ch·∫ø ƒë·ªô l·∫∑p b√†i h√°t hi·ªán t·∫°i.")
    elif mode == "queue":
        await interaction.response.send_message("üîÅ ƒê√£ b·∫≠t ch·∫ø ƒë·ªô l·∫∑p to√†n b·ªô queue.")
    
    logging.info(f"Set loop mode to {mode} for guild {guild_id}")

@bot.tree.command(name="progress", description="Hi·ªÉn th·ªã thanh ti·∫øn tr√¨nh b√†i h√°t ƒëang ph√°t")
async def progress(interaction: discord.Interaction):
    ctx = await bot.get_context(interaction)
    progress_text = await get_progress_bar(ctx, queues)
    await interaction.response.send_message(progress_text)

# Prefix Commands (Restored)
@bot.command(name='play', help='Ph√°t nh·∫°c t·ª´ URL YouTube ho·∫∑c t√¨m ki·∫øm theo t·ª´ kh√≥a')
async def play_prefix(ctx, *, query: str):
    voice_client = await safe_voice_connect(ctx)
    if voice_client is None:
        await ctx.send("‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi voice channel!")
        return
    
    try:
        if "list=" in query or "playlist" in query.lower():
            if await play_playlist(ctx, query, queues):
                if not voice_client.is_playing():
                    await play_next(ctx, voice_client, queues, bot)
                await ctx.send("üé∂ ƒê√£ th√™m playlist v√†o queue!")
        else:
            if await play_song(ctx, query, queues):
                if not voice_client.is_playing():
                    await play_next(ctx, voice_client, queues, bot)
                await ctx.send("üéµ ƒê√£ th√™m b√†i h√°t v√†o queue!")
    except Exception as e:
        await ctx.send(f'‚ùå L·ªói khi ph√°t nh·∫°c: {str(e)}')
        logging.error(f"Error in play command: {e}")

@bot.command(name='skip', help='B·ªè qua b√†i h√°t hi·ªán t·∫°i')
async def skip_prefix(ctx):
    voice_client = ctx.voice_client
    if voice_client is None or not voice_client.is_playing():
        await ctx.send('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t.')
        return
    voice_client.stop()
    await ctx.send('‚è≠Ô∏è ƒê√£ b·ªè qua b√†i h√°t hi·ªán t·∫°i.')
    logging.info(f"Skipped current song in guild {ctx.guild.id}")

@bot.command(name='pause', help='T·∫°m d·ª´ng b√†i h√°t ƒëang ph√°t')
async def pause_prefix(ctx):
    voice_client = ctx.voice_client
    if voice_client is None or not voice_client.is_playing():
        await ctx.send('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t ƒë·ªÉ t·∫°m d·ª´ng.')
        return
    voice_client.pause()
    await ctx.send('‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng b√†i h√°t.')
    logging.info(f"Paused music in guild {ctx.guild.id}")

@bot.command(name='resume', help='Ti·∫øp t·ª•c ph√°t b√†i h√°t ƒë√£ t·∫°m d·ª´ng')
async def resume_prefix(ctx):
    voice_client = ctx.voice_client
    if voice_client is None or not voice_client.is_paused():
        await ctx.send('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang t·∫°m d·ª´ng ƒë·ªÉ ti·∫øp t·ª•c.')
        return
    voice_client.resume()
    await ctx.send('‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c ph√°t b√†i h√°t.')
    logging.info(f"Resumed music in guild {ctx.guild.id}")

@bot.command(name='queue', help='Hi·ªÉn th·ªã danh s√°ch queue nh·∫°c hi·ªán t·∫°i')
async def show_queue_prefix(ctx):
    guild_id = str(ctx.guild.id)
    queue = queues.get(guild_id, [])
    if len(queue) == 0:
        await ctx.send('üìã Queue hi·ªán t·∫°i ƒëang tr·ªëng.')
    else:
        queue_list = []
        for i, (url, audio_url, title, duration) in enumerate(queue):
            duration_str = f"{duration // 60}:{duration % 60:02d}" if duration > 0 else "Unknown"
            status = "üéµ **ƒêang ph√°t**" if i == 0 else f"{i+1}."
            queue_list.append(f'{status} **{title}** ({duration_str})')
        
        result = f'üéµ **Danh s√°ch queue ({len(queue)} b√†i):**\n\n' + '\n'.join(queue_list)
        await ctx.send(result[:2000])
        logging.info(f"Displayed queue for guild {guild_id}")

@bot.command(name='now', help='Hi·ªÉn th·ªã b√†i h√°t ƒëang ph√°t')
async def now_playing_prefix(ctx):
    voice_client = ctx.voice_client
    if voice_client is None or not voice_client.is_playing():
        await ctx.send('‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t.')
        return
    
    guild_id = str(ctx.guild.id)
    queue = queues.get(guild_id, [])
    if queue:
        url, _, title, duration = queue[0]
        duration_str = f"{duration // 60}:{duration % 60:02d}" if duration > 0 else "Unknown"
        await ctx.send(f'üéµ **ƒêang ph√°t:** {title} ({duration_str})')
    else:
        await ctx.send('üéµ ƒêang ph√°t nh·∫°c.')

@bot.command(name='stop', help='D·ª´ng ph√°t nh·∫°c v√† x√≥a queue')
async def stop_prefix(ctx):
    voice_client = ctx.voice_client
    if voice_client is None:
        await ctx.send('‚ùå Ch∆∞a k·∫øt n·ªëi v·ªõi k√™nh voice')
        return
    
    voice_client.stop()
    guild_id = str(ctx.guild.id)
    clear_queue(guild_id)
    queues[guild_id] = []
    loop_status[guild_id] = {"mode": "off", "current_song": None, "start_time": None}
    await ctx.send('‚èπÔ∏è ƒê√£ d·ª´ng nh·∫°c v√† x√≥a queue.')
    logging.info(f"Stopped music and cleared queue for guild {ctx.guild.id}")

@bot.command(name='leave', help='R·ªùi kh·ªèi k√™nh voice')
async def leave_prefix(ctx):
    voice_client = ctx.voice_client
    if voice_client is None:
        await ctx.send('‚ùå Ch∆∞a k·∫øt n·ªëi v·ªõi k√™nh voice')
        return
    
    clear_queue(str(ctx.guild.id))
    queues[str(ctx.guild.id)] = []
    loop_status[str(ctx.guild.id)] = {"mode": "off", "current_song": None, "start_time": None}
    await voice_client.disconnect()
    await ctx.send('üëã ƒê√£ r·ªùi kh·ªèi k√™nh voice.')
    logging.info(f"Left voice channel for guild {ctx.guild.id}")

@bot.command(name='loop', help='B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô l·∫∑p l·∫°i b√†i h√°t ho·∫∑c queue (off, song, queue)')
async def loop_prefix(ctx, mode: str):
    guild_id = str(ctx.guild.id)
    
    if mode not in ["off", "song", "queue"]:
        await ctx.send("‚ùå Ch·∫ø ƒë·ªô kh√¥ng h·ª£p l·ªá! Ch·ªçn: off, song, queue")
        return
    
    loop_status[guild_id] = loop_status.get(guild_id, {})
    loop_status[guild_id]["mode"] = mode
    
    if mode == "off":
        await ctx.send("üîÅ ƒê√£ t·∫Øt ch·∫ø ƒë·ªô l·∫∑p l·∫°i.")
    elif mode == "song":
        await ctx.send("üîÇ ƒê√£ b·∫≠t ch·∫ø ƒë·ªô l·∫∑p b√†i h√°t hi·ªán t·∫°i.")
    elif mode == "queue":
        await ctx.send("üîÅ ƒê√£ b·∫≠t ch·∫ø ƒë·ªô l·∫∑p to√†n b·ªô queue.")
    
    logging.info(f"Set loop mode to {mode} for guild {guild_id}")

@bot.command(name='progress', help='Hi·ªÉn th·ªã thanh ti·∫øn tr√¨nh b√†i h√°t ƒëang ph√°t')
async def progress_prefix(ctx):
    progress_text = await get_progress_bar(ctx, queues)
    await ctx.send(progress_text)

@bot.command(name='join', help='Tham gia k√™nh voice c·ªßa ng∆∞·ªùi d√πng')
async def join(ctx):
    voice_client = await safe_voice_connect(ctx)
    if voice_client:
        logging.info(f"Joined voice channel via join command")

@bot.command(name='search', help='T√¨m ki·∫øm b√†i h√°t m√† kh√¥ng ph√°t (ƒë·ªÉ debug)')
async def search(ctx, *, query: str):
    ydl_opts = {
        'format': 'bestaudio/best',
        'quiet': True,
        'no_warnings': True,
        'socket_timeout': 30,
    }
    
    search_query = f"ytsearch5:{query}"
    
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(search_query, download=False)
            
            if 'entries' in info and info['entries']:
                results = []
                for i, entry in enumerate(info['entries'][:5]):
                    if entry:
                        title = entry.get('title', 'Unknown')
                        uploader = entry.get('uploader', 'Unknown')
                        duration = entry.get('duration', 0)
                        duration_str = f"{duration // 60}:{duration % 60:02d}" if duration > 0 else "Unknown"
                        results.append(f"{i+1}. **{title}**\n   üë§ {uploader} | ‚è±Ô∏è {duration_str}")
                
                result_text = f"üîç K·∫øt qu·∫£ t√¨m ki·∫øm cho '{query}':\n\n" + "\n\n".join(results)
                await ctx.send(result_text[:2000])
            else:
                await ctx.send(f"‚ùå Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ cho: '{query}'")
                
    except Exception as e:
        await ctx.send(f"‚ùå L·ªói khi t√¨m ki·∫øm: {str(e)}")
        logging.error(f"Search error for '{query}': {e}")

@bot.command(name='debug', help='Hi·ªÉn th·ªã th√¥ng tin debug')
async def debug(ctx):
    guild_id = str(ctx.guild.id)
    voice_client = ctx.voice_client
    queue = queues.get(guild_id, [])
    
    debug_info = f"""
**üîß Th√¥ng tin Debug:**
üìç Guild ID: {guild_id}
üîä Voice Client: {'Connected' if voice_client and voice_client.is_connected() else 'Disconnected'}
üéµ Is Playing: {'Yes' if voice_client and voice_client.is_playing() else 'No'}
‚è∏Ô∏è Is Paused: {'Yes' if voice_client and voice_client.is_paused() else 'No'}
üìã Queue Length: {len(queue)}
üíæ Memory Queue: {len(queues.get(guild_id, []))}
üåê Voice Channel: {voice_client.channel.name if voice_client and voice_client.channel else 'None'}
üîÅ Loop Mode: {loop_status.get(guild_id, {}).get('mode', 'off')}
    """
    await ctx.send(debug_info)

@bot.command(name='ffmpeg_test', help='Test FFmpeg')
async def ffmpeg_test(ctx):
    try:
        import subprocess
        result = subprocess.run(['ffmpeg', '-version'], 
                              capture_output=True, text=True, timeout=10)
        await ctx.send(f"FFmpeg version: {result.stdout[:500]}")
    except Exception as e:
        await ctx.send(f"FFmpeg error: {e}")

@bot.command(name='test_stream', help='Test stream URL cho debug')
async def test_stream(ctx, *, query: str):
    from music_player import get_fresh_audio_url, test_stream_url
    
    ydl_opts = {
        'format': 'bestaudio/best',
        'quiet': True,
        'no_warnings': True,
    }
    
    is_url = query.startswith(('http://', 'https://', 'www.'))
    if not is_url:
        query = f"ytsearch1:{query}"
    
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(query, download=False)
            
            if 'entries' in info and info['entries']:
                entry = info['entries'][0]
                if entry:
                    video_url = entry['webpage_url']
                    title = entry.get('title', 'Unknown')
            elif 'webpage_url' in info:
                video_url = info['webpage_url']
                title = info.get('title', 'Unknown')
            else:
                await ctx.send('‚ùå Kh√¥ng t√¨m th·∫•y video')
                return
        
        await ctx.send(f'üîç Testing stream cho: **{title}**')
        
        stream_url = await get_fresh_audio_url(video_url)
        if not stream_url:
            await ctx.send('‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c stream URL')
            return
        
        await ctx.send(f'üì° Stream URL: `{stream_url[:100]}...`')
        await test_stream_url(stream_url, ctx)
        
    except Exception as e:
        await ctx.send(f'‚ùå L·ªói test stream: {str(e)}')

@bot.command(name='voice_debug', help='Debug th√¥ng tin voice connection')
async def voice_debug(ctx):
    vc = ctx.voice_client
    
    debug_info = []
    debug_info.append("üîß **Voice Connection Debug:**")
    debug_info.append(f"üìç Guild: {ctx.guild.name} ({ctx.guild.id})")
    
    if vc:
        debug_info.append(f"üîä Connected: {vc.is_connected()}")
        debug_info.append(f"üéµ Playing: {vc.is_playing()}")
        debug_info.append(f"‚è∏Ô∏è Paused: {vc.is_paused()}")
        debug_info.append(f"üåê Channel: {vc.channel.name if vc.channel else 'None'}")
        debug_info.append(f"üîó Endpoint: {vc.endpoint}")
        debug_info.append(f"üì∂ Average latency: {vc.average_latency:.2f}ms")
        debug_info.append(f"üèì Latency: {vc.latency:.2f}ms")
    else:
        debug_info.append("‚ùå No voice client")
    
    if ctx.author.voice:
        debug_info.append(f"üë§ User channel: {ctx.author.voice.channel.name}")
        debug_info.append(f"üë• Members in channel: {len(ctx.author.voice.channel.members)}")
    else:
        debug_info.append("üë§ User not in voice channel")
    
    await ctx.send('\n'.join(debug_info))

@bot.command(name='force_reconnect', help='Bu·ªôc k·∫øt n·ªëi l·∫°i voice')
async def force_reconnect(ctx):
    if ctx.voice_client:
        await ctx.voice_client.disconnect()
        await asyncio.sleep(2)
    
    voice_client = await safe_voice_connect(ctx)
    if voice_client:
        await ctx.send('‚úÖ ƒê√£ k·∫øt n·ªëi l·∫°i voice th√†nh c√¥ng')
    else:
        await ctx.send('‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi l·∫°i voice')

@bot.command(name='clear_cache', help='X√≥a cache yt-dlp')
async def clear_cache(ctx):
    import shutil
    import os
    
    cache_dir = r'./data/yt_dlp_cache'
    try:
        if os.path.exists(cache_dir):
            shutil.rmtree(cache_dir)
            os.makedirs(cache_dir, exist_ok=True)
            await ctx.send('‚úÖ ƒê√£ x√≥a cache yt-dlp')
        else:
            await ctx.send('üìÅ Cache kh√¥ng t·ªìn t·∫°i')
    except Exception as e:
        await ctx.send(f'‚ùå L·ªói x√≥a cache: {str(e)}')

@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.MissingRequiredArgument):
        await ctx.send('‚ùå Thi·∫øu tham s·ªë b·∫Øt bu·ªôc. S·ª≠ d·ª•ng `!help` ƒë·ªÉ xem h∆∞·ªõng d·∫´n.')
    elif isinstance(error, commands.BadArgument):
        await ctx.send('‚ùå Tham s·ªë kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.')
    elif isinstance(error, commands.CommandNotFound):
        await ctx.send('‚ùå L·ªánh kh√¥ng t·ªìn t·∫°i. S·ª≠ d·ª•ng `!help` ƒë·ªÉ xem danh s√°ch l·ªánh.')
    elif isinstance(error, commands.CommandInvokeError):
        if "TimeoutError" in str(error):
            await ctx.send('‚è∞ L·ªánh b·ªã timeout. Vui l√≤ng th·ª≠ l·∫°i sau.')
        else:
            await ctx.send(f'‚ùå ƒê√£ x·∫£y ra l·ªói khi th·ª±c hi·ªán l·ªánh.')
        logging.error(f"Command error: {error}")
    else:
        await ctx.send(f'‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh.')
        logging.error(f"Unhandled error: {error}")

# Run the bot
bot.run(BOT_TOKEN)